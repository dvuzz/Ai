local Library = {}
local Objects = {Background = {}, GrayContrast = {}, DarkContrast = {}, TextColor = {}, SectionContrast = {}, DropDownListContrast = {}, CharcoalContrast = {}}

-- Modern black/white/gray theme
local Themes = {
	Background = Color3.fromRGB(20, 20, 20),
	GrayContrast = Color3.fromRGB(34, 34, 34),
	DarkContrast = Color3.fromRGB(26, 26, 26),
	TextColor = Color3.fromRGB(235, 235, 235),
	SectionContrast = Color3.fromRGB(38, 38, 38),
	DropDownListContrast = Color3.fromRGB(30, 30, 30),
	CharcoalContrast = Color3.fromRGB(15, 15, 15),
	Accent = Color3.fromRGB(200, 200, 200), -- subtle accent for hover
}

-- Helper: safe instance creation with property assignment
function Library:Create(class, props)
	local inst = Instance.new(class)
	if props then
		for k, v in pairs(props) do
			-- allow Parent always; otherwise guard against invalid properties
			if k == "Parent" then
				inst.Parent = v
			else
				-- pcall assignment because some properties may be read-only for some classes
				pcall(function() inst[k] = v end)
			end
		end
	end
	return inst
end

-- Services
local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local TS = game:GetService("TweenService")
local RS = game:GetService("RunService")

-- Utility tweens
local function tween(inst, props, time, style, dir)
	TS:Create(inst, TweenInfo.new(time or 0.12, Enum.EasingStyle[style or "Quad"], Enum.EasingDirection[dir or "Out"]), props):Play()
end

-- Responsive scaling defaults
local DEFAULT_WIDTH = 700
local DEFAULT_HEIGHT = 460

-- Add common UI decorations (rounded corners, stroke, shadow)
local function decorate(frame, cornerRadius, strokeThickness, shadow)
	if frame and frame:IsA("GuiObject") then
		-- UICorner
		local c = Instance.new("UICorner")
		c.CornerRadius = UDim.new(0, cornerRadius or 10)
		c.Parent = frame
		-- UIStroke
		if strokeThickness and strokeThickness > 0 then
			local s = Instance.new("UIStroke")
			s.Thickness = strokeThickness
			s.Transparency = 0.85
			s.Parent = frame
		end
		-- Shadow (simple using ImageLabel drop shadow)
		if shadow then
			local sh = Instance.new("ImageLabel")
			sh.Name = "DropShadow"
			sh.AnchorPoint = Vector2.new(0.5, 0.5)
			sh.BackgroundTransparency = 1
			sh.Image = "rbxassetid://5058852364" -- generic soft shadow (built-in-ish). If unavailable, it's okay.
			sh.ScaleType = Enum.ScaleType.Slice
			sh.SliceCenter = Rect.new(10,10,246,246)
			sh.SliceScale = 0.01
			sh.Size = UDim2.new(1.06, 0, 1.06, 0)
			sh.Position = UDim2.new(0.5, 0, 0.5, 4)
			sh.ZIndex = (frame.ZIndex or 1) - 1
			sh.ImageColor3 = Color3.fromRGB(0,0,0)
			sh.ImageTransparency = 0.75
			sh.Parent = frame
		end
	end
end

-- Auto-detect mobile and scale factors
local function getScaleFactors(rootSize)
	local screenW = rootSize and rootSize.X or DEFAULT_WIDTH
	local screenH = rootSize and rootSize.Y or DEFAULT_HEIGHT
	-- base scale by height
	local base = math.clamp(screenH / DEFAULT_HEIGHT, 0.6, 1.5)
	local textScale = math.clamp(math.floor(18 * base), 12, 24)
	return {base = base, text = textScale}
end

-- Improved drag function supporting touch and mouse, with smoothing
local function enableDrag(guiFrame)
	local dragging, dragStart, startPos, dragInput
	local last = tick()
	local smoothing = 0.12
	local targetPos = guiFrame.Position

	local function update(input)
		if not dragging or not dragStart or not startPos then return end
		local delta = input.Position - dragStart
		targetPos = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end

	guiFrame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = guiFrame.Position
			dragInput = input
		end
	end)

	guiFrame.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)

	UIS.InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			update(input)
		end
	end)

	UIS.InputEnded:Connect(function(input)
		if input == dragInput then
			dragging = false
			dragStart = nil
			dragInput = nil
		end
	end)

	-- Smooth tween loop
	local conn
	conn = RS.RenderStepped:Connect(function(dt)
		if not conn then return end
		-- interpolate current position toward target
		local cur = guiFrame.Position
		local nx = cur:Lerp(targetPos, smoothing)
		guiFrame.Position = nx
	end)
	-- disconnect when gui removed
	guiFrame.AncestryChanged:Connect(function()
		if not guiFrame:IsDescendantOf(game) then
			if conn then conn:Disconnect(); conn = nil end
		end
	end)
end

-- Main creation function (keeps same API; accepts Options table)
function Library:CreateMain(Options)
	Options = Options or {}
	local projName = Options.projName or "OrionLibrary_Improved"
	local Resizable = Options.Resizable or false
	local MinSize = Options.MinSize or UDim2.new(0, 420, 0, 280)
	local MaxSize = Options.MaxSize or UDim2.new(0, 1200, 0, 900)

	local Main = {}
	local firstCategory = true

	-- ScreenGui
	Main.Screengui = Library:Create("ScreenGui", {
		Name = projName,
		ZIndexBehavior = Enum.ZIndexBehavior.Global,
		ResetOnSpawn = false,
		Enabled = true,
		Parent = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui") or game:GetService("CoreGui")
	})

	-- Motherframe (centered)
	local defaultW = Options.DefaultSize and Options.DefaultSize.X.Offset or DEFAULT_WIDTH
	local defaultH = Options.DefaultSize and Options.DefaultSize.Y.Offset or DEFAULT_HEIGHT

	Main.Motherframe = Library:Create("Frame", {
		Name = "Motherframe",
		BackgroundColor3 = Themes.Background,
		BorderSizePixel = 0,
		Position = UDim2.new(0.5, -defaultW/2, 0.5, -defaultH/2),
		Size = UDim2.new(0, defaultW, 0, defaultH),
		Active = true,
		Parent = Main.Screengui,
		ZIndex = 50,
	})

	table.insert(Objects.Background, Main.Motherframe)
	decorate(Main.Motherframe, 14, 0.8, true)

	-- Top bar (title and toggle)
	Main.TopBar = Library:Create("Frame", {
		Name = "TopBar",
		Parent = Main.Motherframe,
		Size = UDim2.new(1, 0, 0, 38),
		BackgroundTransparency = 1,
		ZIndex = 51,
	})
	Main.Title = Library:Create("TextLabel", {
		Name = "Title",
		Parent = Main.TopBar,
		Position = UDim2.new(0, 12, 0, 6),
		Size = UDim2.new(0.6, 0, 0, 28),
		Font = Enum.Font.GothamBold,
		Text = Options.projName or "Library",
		TextColor3 = Themes.TextColor,
		TextSize = 18,
		BackgroundTransparency = 1,
		TextXAlignment = Enum.TextXAlignment.Left,
	})
	table.insert(Objects.TextColor, Main.Title)

	-- Open/Close button for mobile friendliness
	Main.ToggleBtn = Library:Create("ImageButton", {
		Name = "ToggleBtn",
		Parent = Main.TopBar,
		AnchorPoint = Vector2.new(1, 0),
		Position = UDim2.new(1, -10, 0, 6),
		Size = UDim2.new(0, 28, 0, 28),
		BackgroundTransparency = 1,
		AutoButtonColor = true,
		Image = "rbxassetid://6441351252", -- hamburger-like icon; if missing, change to another id
		ImageColor3 = Themes.TextColor,
		ZIndex = 52,
	})
	table.insert(Objects.TextColor, Main.ToggleBtn)

	-- Subtle underline accent under top bar
	Main.Upline = Library:Create("Frame", {
		Name = "Upline",
		Parent = Main.Motherframe,
		BackgroundColor3 = Color3.new(1,1,1),
		BackgroundTransparency = 0.95,
		Size = UDim2.new(1, 0, 0, 2),
		Position = UDim2.new(0,0,0,38),
		ZIndex = 51,
	})
	Main.Upline.BackgroundColor3 = Color3.fromRGB(70,70,70)

	-- Sidebar (left) and content area (right)
	Main.Sidebar = Library:Create("ScrollingFrame", {
		Name = "Sidebar",
		Parent = Main.Motherframe,
		Active = true,
		BackgroundColor3 = Themes.GrayContrast,
		BorderSizePixel = 0,
		Position = UDim2.new(0, 12, 0, 50),
		Size = UDim2.new(0.22, -18, 0.9, -60),
		CanvasSize = UDim2.new(0, 0, 0, 0),
		ScrollBarThickness = 6,
		ZIndex = 51,
	})
	table.insert(Objects.GrayContrast, Main.Sidebar)
	decorate(Main.Sidebar, 10, 0.5, false)

	-- Category container (right)
	Main.Categorieshandler = Library:Create("Frame", {
		Name = "Categories",
		Parent = Main.Motherframe,
		BackgroundColor3 = Themes.Background,
		BorderSizePixel = 0,
		Position = UDim2.new(0.22, 0, 0, 50),
		Size = UDim2.new(0.78, -12, 0.9, -60),
		ZIndex = 51,
	})
	table.insert(Objects.GrayContrast, Main.Categorieshandler)

	-- Sidebar padding + layout
	local siderPad = Library:Create("UIPadding", {
		PaddingTop = UDim.new(0, 12),
		PaddingLeft = UDim.new(0, 10),
		Parent = Main.Sidebar,
	})
	local sideLayout = Library:Create("UIListLayout", {
		Parent = Main.Sidebar,
		SortOrder = Enum.SortOrder.LayoutOrder,
		Padding = UDim.new(0, 10),
	})

	-- Make draggable
	enableDrag(Main.Motherframe)

	-- Toggle behavior (hide/show)
	local hidden = false
	Main.ToggleBtn.MouseButton1Click:Connect(function()
		hidden = not hidden
		if hidden then
			tween(Main.Motherframe, {Position = UDim2.new(0, 10, 0.5, -(Main.Motherframe.Size.Y.Offset/2))}, 0.18, "Quad", "In")
			tween(Main.Motherframe, {Size = UDim2.new(0, 40, 0, 40)}, 0.18, "Quad", "In")
		else
			-- restore center position
			local centerPos = UDim2.new(0.5, -Main.Motherframe.Size.X.Offset/2, 0.5, -Main.Motherframe.Size.Y.Offset/2)
			tween(Main.Motherframe, {Position = centerPos, Size = Main.Motherframe.Size}, 0.18, "Quad", "Out")
		end
	end)

	-- Responsive text size setter
	local function applyTextSizes(baseTextSize)
		for _, v in pairs(Main.Motherframe:GetDescendants()) do
			if v:IsA("TextLabel") or v:IsA("TextButton") or v:IsA("TextBox") then
				if v ~= Main.Title then
					v.TextSize = baseTextSize
				end
			end
		end
		-- Title slightly larger
		Main.Title.TextSize = math.clamp(baseTextSize + 2, 14, 30)
	end

	-- Initial scale based on default size
	local scaleFactors = getScaleFactors(Vector2.new(Main.Motherframe.Size.X.Offset, Main.Motherframe.Size.Y.Offset))
	applyTextSizes(scaleFactors.text)

	-- Allow resizing with handle (only if Resizable)
	if Resizable then
		local resize = Library:Create("Frame", {
			Parent = Main.Motherframe,
			Name = "ResizeHandle",
			Size = UDim2.new(0, 18, 0, 18),
			Position = UDim2.new(1, -20, 1, -20),
			BackgroundTransparency = 1,
			ZIndex = 60,
		})
		local grip = Library:Create("ImageLabel", {
			Parent = resize,
			AnchorPoint = Vector2.new(0.5,0.5),
			Position = UDim2.new(0.5,0,0.5,0),
			Size = UDim2.new(1,0,1,0),
			Image = "rbxassetid://3570695787",
			ImageColor3 = Themes.GrayContrast,
			BackgroundTransparency = 1,
		})
		enableDrag(resize) -- lightweight drag to change size
		-- Simple resize via mouse drag events
		local resizing = false
		local startMouse = nil
		local startSize = nil
		resize.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				resizing = true
				startMouse = input.Position
				startSize = Main.Motherframe.Size
			end
		end)
		UIS.InputChanged:Connect(function(input)
			if resizing and input.UserInputType == Enum.UserInputType.MouseMovement then
				local delta = input.Position - startMouse
				local newW = math.clamp(startSize.X.Offset + delta.X, MinSize.X.Offset, MaxSize.X.Offset)
				local newH = math.clamp(startSize.Y.Offset + delta.Y, MinSize.Y.Offset, MaxSize.Y.Offset)
				Main.Motherframe.Size = UDim2.new(0, newW, 0, newH)
				-- update text sizes
				local sf = getScaleFactors(Vector2.new(newW, newH))
				applyTextSizes(sf.text)
			end
		end)
		UIS.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				resizing = false
			end
		end)
	end

	-- Category creation
	local CategoryDistanceCounter = 0
	function Main:CreateCategory(Name)
		local Category = {}

		local catBtn = Library:Create("TextButton", {
			Parent = Main.Sidebar,
			Name = Name .. "Button",
			BackgroundTransparency = 1,
			Text = Name,
			Font = Enum.Font.GothamBold,
			TextColor3 = Themes.TextColor,
			TextSize = 16,
			TextXAlignment = Enum.TextXAlignment.Left,
			Size = UDim2.new(1, -20, 0, 34),
			AutoButtonColor = true,
		})
		table.insert(Objects.TextColor, catBtn)

		local catContainer = Library:Create("ScrollingFrame", {
			Parent = Main.Categorieshandler,
			Name = Name.."Category",
			BackgroundColor3 = Themes.Background,
			BorderSizePixel = 0,
			Position = UDim2.new(0, 12, 0, 0),
			Size = UDim2.new(1, -24, 1, -12),
			CanvasSize = UDim2.new(0, 0, 0, 0),
			ScrollBarThickness = 8,
			Visible = false,
		})
		table.insert(Objects.CharcoalContrast, catContainer)
		decorate(catContainer, 10, 0.4, false)

		local pad = Library:Create("UIPadding", {Parent = catContainer, PaddingTop = UDim.new(0, 12), PaddingLeft = UDim.new(0, 12)})
		local layout = Library:Create("UIListLayout", {Parent = catContainer, SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 10)})

		if firstCategory then
			catContainer.Visible = true
			firstCategory = false
		end

		catBtn.MouseButton1Click:Connect(function()
			-- slide selector animation (we simply highlight button quickly)
			for _, v in pairs(Main.Sidebar:GetChildren()) do
				if v:IsA("TextButton") then
					tween(v, {TextColor3 = Themes.TextColor}, 0.12)
				end
			end
			tween(catBtn, {TextColor3 = Themes.Accent}, 0.12)
			-- show appropriate container
			for _, v in pairs(Main.Categorieshandler:GetChildren()) do
				if v:IsA("ScrollingFrame") then v.Visible = false end
			end
			catContainer.Visible = true
		end)

		Category.CButton = catBtn
		Category.Container = catContainer

		-- Create section function (keeps original API)
		function Category:CreateSection(SectionName)
			local Section = {}

			local sectionBox = Library:Create("Frame", {
				Name = SectionName.."Section",
				Parent = Category.Container,
				BackgroundColor3 = Themes.SectionContrast,
				Size = UDim2.new(1, 0, 0, 46),
				BorderSizePixel = 0,
			})
			decorate(sectionBox, 8, 0.3, false)

			local sectionTitle = Library:Create("TextLabel", {
				Parent = sectionBox,
				Name = "Name",
				BackgroundTransparency = 1,
				Position = UDim2.new(0, 8, 0, 4),
				Size = UDim2.new(0.6, 0, 0, 28),
				Font = Enum.Font.GothamBold,
				Text = SectionName,
				TextColor3 = Themes.TextColor,
				TextSize = 16,
				TextXAlignment = Enum.TextXAlignment.Left,
			})
			table.insert(Objects.TextColor, sectionTitle)

			local contentFrame = Library:Create("Frame", {
				Parent = sectionBox,
				Name = "Content",
				BackgroundTransparency = 1,
				Position = UDim2.new(0, 8, 0, 34),
				Size = UDim2.new(1, -16, 0, 0), -- height will expand
				ClipsDescendants = true,
			})

			local contentLayout = Library:Create("UIListLayout", {
				Parent = contentFrame,
				SortOrder = Enum.SortOrder.LayoutOrder,
				Padding = UDim.new(0, 8),
			})

			-- Helper to expand container sizes
			local function expandHeights(delta)
				sectionBox.Size = sectionBox.Size + UDim2.new(0, 0, 0, delta)
				Category.Container.CanvasSize = UDim2.new(0, 0, 0, Category.Container.CanvasSize.Y.Offset + delta)
			end

			Section.Container = contentFrame
			Section.SectionName = sectionTitle

			-- Keep existing Create Type API (button, slider, toggle, textbox, textlabel, keybind, dropdown)
			function Section:Create(Type, Name, CallBack, Options)
				Type = (Type or ""):lower()
				Options = Options or {}

				-- BUTTON
				if Type == "button" then
					local frame = Library:Create("Frame", {
						Parent = contentFrame,
						BackgroundTransparency = 1,
						Size = UDim2.new(1, 0, 0, 36),
					})
					local btn = Library:Create("TextButton", {
						Parent = frame,
						Size = UDim2.new(1, 0, 1, 0),
						BackgroundColor3 = Themes.DarkContrast,
						AutoButtonColor = true,
						Font = Enum.Font.GothamBold,
						Text = Name,
						TextColor3 = Themes.TextColor,
						TextSize = 16,
					})
					decorate(btn, 8, 0.3, false)
					table.insert(Objects.DarkContrast, btn)
					table.insert(Objects.TextColor, btn)

					btn.MouseButton1Click:Connect(function()
						if Options.animated then
							tween(btn, {Size = UDim2.new(1, 0, 1, -6)}, 0.06, "Sine", "InOut")
							wait(0.07)
							tween(btn, {Size = UDim2.new(1, 0, 1, 0)}, 0.06, "Sine", "InOut")
						end
						if CallBack then
							CallBack()
						end
					end)

					expandHeights(44)
					return btn

				-- SLIDER
				elseif Type == "slider" then
					local min = Options.min or 0
					local max = Options.max or 100
					local default = Options.default or min
					local precise = Options.precise or false

					local frame = Library:Create("Frame", {Parent = contentFrame, BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 60)})
					local bg = Library:Create("Frame", {Parent = frame, BackgroundColor3 = Themes.DarkContrast, Size = UDim2.new(1, 0, 0, 40)})
					decorate(bg, 8, 0.3, false)
					local label = Library:Create("TextLabel", {Parent = bg, Position = UDim2.new(0, 8, 0, 6), Size = UDim2.new(0.6, 0, 0, 24), BackgroundTransparency = 1, Font = Enum.Font.GothamBold, Text = Name, TextColor3 = Themes.TextColor, TextSize = 16, TextXAlignment = Enum.TextXAlignment.Left})
					local valueLabel = Library:Create("TextLabel", {Parent = bg, AnchorPoint = Vector2.new(1,0), Position = UDim2.new(1, -8, 0, 6), Size = UDim2.new(0.2, 0, 0, 24), BackgroundTransparency = 1, Font = Enum.Font.GothamBold, Text = tostring(default), TextColor3 = Themes.TextColor, TextSize = 16, TextXAlignment = Enum.TextXAlignment.Right})
					local sliderBack = Library:Create("Frame", {Parent = bg, Position = UDim2.new(0.04, 0, 0, 34), Size = UDim2.new(0.92, 0, 0, 8), BackgroundColor3 = Themes.CharcoalContrast, BorderSizePixel = 0})
					decorate(sliderBack, 6, 0, false)
					local sliderInner = Library:Create("Frame", {Parent = sliderBack, Position = UDim2.new(0,0,0,0), Size = UDim2.new( ((default - min) / math.max(1, max - min)), 0, 1, 0), BackgroundColor3 = Themes.TextColor})
					decorate(sliderInner, 6, 0, false)

					local dragging = false
					local function updateSlider(absX)
						local rel = math.clamp((absX - sliderBack.AbsolutePosition.X) / sliderBack.AbsoluteSize.X, 0, 1)
						local v = (min + (max - min) * rel)
						if not precise then v = math.floor(v) end
						valueLabel.Text = tostring(v)
						sliderInner.Size = UDim2.new(rel, 0, 1, 0)
						if CallBack then CallBack(v) end
					end

					sliderBack.InputBegan:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
							dragging = true
							updateSlider(input.Position.X)
						end
					end)
					sliderBack.InputEnded:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
							dragging = false
						end
					end)
					UIS.InputChanged:Connect(function(input)
						if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
							updateSlider(input.Position.X)
						elseif dragging and input.UserInputType == Enum.UserInputType.Touch then
							updateSlider(input.Position.X)
						end
					end)

					expandHeights(68)
					return {Slider = sliderInner, Set = function(val)
						local rel = math.clamp((val - min) / math.max(1, (max-min)), 0, 1)
						sliderInner.Size = UDim2.new(rel, 0, 1, 0)
						valueLabel.Text = tostring(val)
					end}

				-- TOGGLE
				elseif Type == "toggle" then
					local state = false
					if Options.default then state = true end

					local frame = Library:Create("Frame", {Parent = contentFrame, BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 44)})
					local bg = Library:Create("Frame", {Parent = frame, BackgroundColor3 = Themes.DarkContrast, Size = UDim2.new(1,0,0,36)})
					decorate(bg, 8, 0.3, false)
					local label = Library:Create("TextLabel", {Parent = bg, Position = UDim2.new(0, 8, 0, 6), Size = UDim2.new(0.6, 0, 0, 24), BackgroundTransparency = 1, Font = Enum.Font.GothamBold, Text = Name, TextColor3 = Themes.TextColor, TextSize = 16, TextXAlignment = Enum.TextXAlignment.Left})
					local toggleBtn = Library:Create("ImageButton", {Parent = bg, AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.new(0, 48, 0, 26), BackgroundTransparency = 1, AutoButtonColor = false})
					local toggleBack = Library:Create("Frame", {Parent = toggleBtn, BackgroundColor3 = Themes.CharcoalContrast, Size = UDim2.new(1,0,1,0)})
					local toggleDot = Library:Create("Frame", {Parent = toggleBack, BackgroundColor3 = Themes.TextColor, Size = UDim2.new(0,0,1,0), Position = UDim2.new(0,2,0,0)})
					decorate(toggleBack, 12, 0, false)
					decorate(toggleDot, 12, 0, false)

					local function setState(s)
						state = s
						if state then
							tween(toggleDot, {Position = UDim2.new(1, - (toggleDot.AbsoluteSize.X + 4), 0, 0)}, 0.12, "Quad", "Out")
						else
							tween(toggleDot, {Position = UDim2.new(0, 2, 0, 0)}, 0.12, "Quad", "Out")
						end
						if CallBack then CallBack(state) end
					end

					-- init
					-- ensure sizes computed after render
					delay(0.03, function()
						toggleDot.Size = UDim2.new(0.45, 0, 1, 0)
						if state then
							toggleDot.Position = UDim2.new(1, - (toggleDot.AbsoluteSize.X + 4), 0, 0)
						else
							toggleDot.Position = UDim2.new(0, 2, 0, 0)
						end
					end)

					toggleBtn.MouseButton1Click:Connect(function()
						setState(not state)
					end)

					expandHeights(52)
					return {Set = setState, Get = function() return state end}

				-- TEXTBOX
				elseif Type == "textbox" then
					local placeholder = Options.text or "Text"
					local frame = Library:Create("Frame", {Parent = contentFrame, BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 48)})
					local bg = Library:Create("Frame", {Parent = frame, BackgroundColor3 = Themes.DarkContrast, Size = UDim2.new(1,0,0,36)})
					decorate(bg, 8, 0.3, false)
					local label = Library:Create("TextLabel", {Parent = bg, Position = UDim2.new(0, 8, 0, 6), Size = UDim2.new(0.45, 0, 0, 24), BackgroundTransparency = 1, Font = Enum.Font.GothamBold, Text = Name, TextColor3 = Themes.TextColor, TextSize = 16, TextXAlignment = Enum.TextXAlignment.Left})
					local boxBack = Library:Create("Frame", {Parent = bg, AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.new(0.48, 0, 0.82, 0), BackgroundColor3 = Themes.CharcoalContrast})
					decorate(boxBack, 6, 0, false)
					local txt = Library:Create("TextBox", {Parent = boxBack, BackgroundTransparency = 1, Size = UDim2.new(1, -8, 1, 0), Position = UDim2.new(0, 4, 0, 0), Font = Enum.Font.GothamBold, PlaceholderText = placeholder, Text = "", TextColor3 = Themes.TextColor, TextSize = 16, ClearTextOnFocus = false, TextXAlignment = Enum.TextXAlignment.Left})
					txt.FocusLost:Connect(function(enter)
						if CallBack then CallBack(txt.Text) end
					end)

					expandHeights(56)
					return txt

				-- TEXTLABEL
				elseif Type == "textlabel" then
					local frame = Library:Create("Frame", {Parent = contentFrame, BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 44)})
					local bg = Library:Create("Frame", {Parent = frame, BackgroundColor3 = Themes.DarkContrast, Size = UDim2.new(1,0,0,36)})
					decorate(bg, 8, 0.3, false)
					local label = Library:Create("TextLabel", {Parent = bg, Position = UDim2.new(0, 8, 0, 6), Size = UDim2.new(0.98, 0, 0, 24), BackgroundTransparency = 1, Font = Enum.Font.GothamBold, Text = Name, TextColor3 = Themes.TextColor, TextSize = 16, TextXAlignment = Enum.TextXAlignment.Left})
					expandHeights(52)
					return label

				-- KEYBIND (keeps previous behavior but without Enum.KeyCode references removal)
				elseif Type == "keybind" then
					local frame = Library:Create("Frame", {Parent = contentFrame, BackgroundTransparency = 1, Size = UDim2.new(1,0,0,48)})
					local bg = Library:Create("Frame", {Parent = frame, BackgroundColor3 = Themes.DarkContrast, Size = UDim2.new(1,0,0,36)})
					decorate(bg, 8, 0.3, false)
					local label = Library:Create("TextLabel", {Parent = bg, Position = UDim2.new(0, 8, 0, 6), Size = UDim2.new(0.6, 0, 0, 24), BackgroundTransparency = 1, Font = Enum.Font.GothamBold, Text = Name, TextColor3 = Themes.TextColor, TextSize = 16, TextXAlignment = Enum.TextXAlignment.Left})
					local keyBtn = Library:Create("TextButton", {Parent = bg, AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.new(0, 110, 0, 26), BackgroundColor3 = Themes.CharcoalContrast, Font = Enum.Font.GothamBold, Text = "None", TextColor3 = Themes.TextColor, TextSize = 14})
					decorate(keyBtn, 6, 0.3, false)

					local currentBind
					local binding = false
					keyBtn.MouseButton1Click:Connect(function()
						binding = true
						keyBtn.Text = "Press..."
						local conn
						conn = UIS.InputBegan:Connect(function(input, gp)
							if gp then return end
							if input.UserInputType == Enum.UserInputType.Keyboard then
								currentBind = input.KeyCode
								keyBtn.Text = currentBind.Name
								binding = false
								if conn then conn:Disconnect() end
							end
						end)
					end)

					-- listen for activation
					local inputConn = UIS.InputBegan:Connect(function(input, gp)
						if not gp and currentBind and input.KeyCode == currentBind and CallBack and not binding then
							CallBack(input.KeyCode)
						end
					end)

					-- cleanup on GUI destroy
					Main.Screengui.AncestryChanged:Connect(function()
						if not Main.Screengui:IsDescendantOf(game) then
							if inputConn then inputConn:Disconnect() end
						end
					end)

					expandHeights(56)
					return {Set = function(k) currentBind = k; keyBtn.Text = k and k.Name or "None" end}

				-- DROPDOWN (basic, no search)
				elseif Type == "dropdown" then
					local tablelist = {}
					if Options.options then
						for _,v in ipairs(Options.options) do table.insert(tablelist, v) end
					end
					-- selected default
					local selected = Options.default or tablelist[1] or "None"

					local frame = Library:Create("Frame", {Parent = contentFrame, BackgroundTransparency = 1, Size = UDim2.new(1,0,0,44)})
					local bg = Library:Create("Frame", {Parent = frame, BackgroundColor3 = Themes.DarkContrast, Size = UDim2.new(1,0,0,36)})
					decorate(bg, 8, 0.3, false)
					local label = Library:Create("TextLabel", {Parent = bg, Position = UDim2.new(0,8,0,6), Size = UDim2.new(0.5,0,0,24), BackgroundTransparency = 1, Font = Enum.Font.GothamBold, Text = Name, TextColor3 = Themes.TextColor, TextSize = 16, TextXAlignment = Enum.TextXAlignment.Left})
					local selBtn = Library:Create("TextButton", {Parent = bg, AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.new(0, 160, 0, 26), BackgroundColor3 = Themes.CharcoalContrast, Font = Enum.Font.GothamBold, Text = tostring(selected), TextColor3 = Themes.TextColor, TextSize = 14})
					decorate(selBtn, 6, 0.3, false)

					local dropdownOpen = false
					local listFrame = Library:Create("Frame", {Parent = frame, BackgroundTransparency = 1, Position = UDim2.new(0,0,1,4), Size = UDim2.new(1,0,0,0), ClipsDescendants = true})
					local listBg = Library:Create("Frame", {Parent = listFrame, BackgroundColor3 = Themes.DropDownListContrast, Size = UDim2.new(1,0,0,150)})
					decorate(listBg, 8, 0.3, false)
					local listScrolling = Library:Create("ScrollingFrame", {Parent = listBg, BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), CanvasSize = UDim2.new(0,0,0,0), ScrollBarThickness = 6})
					local listLayout = Library:Create("UIListLayout", {Parent = listScrolling, SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0,6)})

					local function refreshList()
						for _, v in pairs(listScrolling:GetChildren()) do
							if v:IsA("TextButton") then v:Destroy() end
						end
						for i, opt in ipairs(tablelist) do
							local b = Library:Create("TextButton", {Parent = listScrolling, Size = UDim2.new(1, -16, 0, 30), Position = UDim2.new(0, 8, 0, 0), BackgroundColor3 = Themes.DarkContrast, AutoButtonColor = true, Text = tostring(opt), Font = Enum.Font.GothamBold, TextColor3 = Themes.TextColor, TextSize = 14})
							decorate(b, 6, 0.2, false)
							b.MouseButton1Click:Connect(function()
								selected = opt
								selBtn.Text = tostring(selected)
								-- close
								dropdownOpen = false
								tween(listFrame, {Size = UDim2.new(1,0,0,0)}, 0.12, "Quad", "In")
								if CallBack then CallBack(selected) end
							end)
						end
						-- update canvas
						local contentHeight = (listLayout.AbsoluteContentSize.Y) + 16
						listScrolling.CanvasSize = UDim2.new(0,0,0,contentHeight)
						listBg.Size = UDim2.new(1,0,0, math.clamp(contentHeight, 0, 200))
					end

					refreshList()
					selBtn.MouseButton1Click:Connect(function()
						dropdownOpen = not dropdownOpen
						if dropdownOpen then
							refreshList()
							tween(listFrame, {Size = UDim2.new(1,0,0,math.clamp(listBg.Size.Y.Offset, 60, 200))}, 0.12, "Quad", "Out")
						else
							tween(listFrame, {Size = UDim2.new(1,0,0,0)}, 0.12, "Quad", "In")
						end
					end)

					expandHeights(56)
					-- expose setter/getter
					return {
						SetOptions = function(t)
							tablelist = {}
							for _,v in ipairs(t) do table.insert(tablelist, v) end
							refreshList()
						end,
						GetSelected = function() return selected end,
						SetSelected = function(v) selected = v; selBtn.Text = tostring(v) end
					}
				end
			end -- Section:Create end

			-- update initial heights
			Category.Container.CanvasSize = UDim2.new(0, 0, 0, Category.Container.CanvasSize.Y.Offset + sectionBox.Size.Y.Offset + 16)
			return Section
		end -- CreateSection end

		-- append to sidebar (keeps old style positions)
		table.insert(Objects.GrayContrast, catBtn)
		Category.CButton = catBtn
		Category.Container = catContainer

		return Category
	end

	-- Return Main object with functions
	return Main
end

return Library